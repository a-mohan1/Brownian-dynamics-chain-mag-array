c     This program simulates the motion of a chain
c     in a magnetic obstacle array
c     periodic unit cell dims = L, W,  2-dimensional
c     (infinite in z-direction)
c     lattice starts at x=0
c     origin is at lower left hand corner of unit cell
c     Initially, the chain is in a coil config.
c     with the first bead at (-xstart, W/2, 0), 
c     ie, upstream, along unit cell centerline
c     before equilibration in array
c     Free draining conditions are assumed
c
c     generalization of mobstart.f
c
c     Apr 17 07
c
      program mobstartq

c     xc, yc, zc, xn, yn, zn = bead coords at successive time steps
c     nbeads = number of beads
c     a = bead radius (for HSEV implementation)
c     sprtype = type of spring (WLS = 4)
c     nens = ensemble size
c     Hspr = spring constant
c     whicRNG = RNG (Knuth = 1)
c     nseed = seed for RNG (-ve integer for whicRNG=1)
c     ranflag = indicates whether or not RNG has been initialized; initialized to 0
c     deltar = time step size for array simulation
c     deltinit = time step size for generating eq. coil
c     Nks = number of Kuhn segments per spring
c     lambda = ratio of effective to true persistence length
c     v = EV param
c     Pe = Peclet number (\mu_0 E N \zeta A)/(k_B T)
c     uve = unit vector in field direction, x: (1,0,0)
c     ntstepseq = # time steps simulated for each traj. to reach equilibration
c     ntstepsva = # time steps simulated for each traj. after eq. for each sample
c     (in each viewing area)
c     nva = # viewing areas or # samples collected following eq. per traj.
c     xcmi, ycmi = center of mass coords at the start of each viewing area
c     for each traj.
c     xcmva, ycmva = center of mass coords at the end of each viewing area 
c     relative to starting values
c     ncolls = #collisions in viewing area per column for each sample
c     lspac = average lattice spacing 
c     (from RaminsCode/postprocess/spacing/space-vs-t)
c     ncol = #lattice columns in viewing area, nonintegral 
c     ie, distance covered by chain per viewing area/average lattice spacing
c     ncol = xcmva(isamp)/lspac, not the same for all chains
c     numcoll = total #collisions in given viewing area for given traj
c     sobsx, sobsy = saved obstacle center coords with which collisions have
c     occurred in current trajectory in current viewing area
c     maxcoll = max allowed # collisions per sample
c     (size of arrays sobsx, sobsy)
c     colldist = mean distance covered between successive collisions for each sample
c     xobs, yobs = array of obstacle center xy coords in periodic unit cell
c     Robs = obstacle radius
c     Nobs = total# obstacles in periodic unit cell
c     lens = length scale = max spring length
c     L, W = length and width of periodic unit cell
c     (obst centers lie in unit cell, but some portion of obst may lie outside)
c     Nbinsx, Nbinsy = # bins for obsts along x, y directions
c     Nbinsx = int(sqrt(Nobs * L/W))
c     Nbinsy = int(sqrt(Nobs * W/L))
c     => Nbinsx/Nbinsy = L/W
c     Nbins = total # bins = Nbinsx*Nbinsy
c     binsizex, binsizey = bin dimensions along x and y
c     binsizex = L/Nbinsx, binsizey = W/Nbinsy 
c     => binsizex * binsizey * Nbins = L*W
c     binhead = array of head obstacles of each bin
c     binlist = array of remaining obstacles of each bin pointed to by head
c     xstart = to be subtracted from bead x coords in starting config 
c     (chain is placed upstream along unit cell centerline)
c     overext indicates whether a spring has been overstretched
c     isgev = .TRUE. if gaussian EV is included
c     istab indicates whether or not a lookup table exists 
c     (reqd by predictor-corrector scheme)
c     iseqconfig indicates whether or not an initial eqm config
c     has been generated by subroutine geninit
c     istep = counter for time stepping
c     ibead = counter for beads
c     iobs = obstacle counter
c     iens = counter over trajectories in ensemble
c     iva = viewing area counter
c     xeq, yeq, zeq = initial eqm bead coords
c     Config. returned by geninit has first bead at (0, 0, 0)
c     shifted upstream of channel centerline by subroutine inchainconf
c     Rousetime = Rouse rel time
c     xmin, xmax = min and max chain x coords in field (x) direction
c     ymin, ymax = min and max chain y coords
c     xcm = center of mass x coord at given time point
c     isamp = sampling index
c     nsamp = sample size = nva*nens
c     sstep = interval of #steps after which config is saved
c     estret = ens-av chain stretch in field direction during equilibration
c     emsdx = ens-av mean sq displacement in field(x) dir during equilibr.
c     relative to position of initial coil config 
c     ecmx = ens-av mean c.m. position in x dir during equilibr.
c     relative to position of initial coil config
c     estret, emsdx, ecmx are meaningful only if equilibrated config is generated
c     vstret = ens-av chain stretch in field direction for view areas
c     vmsdx = ens-av mean sq displacement in field(x) dir 
c     for all view areas relative to position at start of each view ar
c     vcmx = ens-av mean c.m. position in x dir
c     for all view areas relative to position at start of each view ar
c     inde = array index during equilibration, initialized to 0 in inchainconf
c     for each traj.
c     ind = array index in view areas
c     final values of inde, ind = final array sizes
c     vmsdx, vcmx contain blocks of data corresp to each view ar.
c     relative to starting coords for that view ar.
c     maxind = max array size
c     inovercnt = # times pred corr method gets overextended spring
c     outovercnt = # times pred corr method returns overextended spring
c                  (never used, since program is stopped if this happens)
c     isobscoords = indicates whether file movie.xyz containing obst coords exists
c     iscoords = indicates whether file containing equilibrated bead coords exists
c     readcoords = indicates whether or not to read bead coords from file
c     nobsfile = unit# of movie.xyz file
c     nchainfile = unit# of bead coords file
c
c     all eqs and variables are nondimensional
c     nondimensional max spring length = 1.0
c
c     This program doesn't work if deltinit and deltar are unequal 
c     because the lookup table is created only once during the program 
c     and works only for a fixed value of delt
c     So to use two time steps, reset istab to .FALSE. in subroutine inchainconf 
c     each time before and after generating the initial coil config


      implicit none
      real etime, elapsed(2)

      integer nbeads, ntstepseq, ntstepsva, sprtype, whicRNG, nseed
      integer ranflag, nens, Nobs, Nbinsx, Nbinsy, Nbins, nva, nsamp
      integer maxcoll, nobsfile, nchainfile, sstep, maxind, inde, ind
      integer istep, ibead, iobs, iens, isamp, iva
      integer inovercnt, outovercnt, numcoll

      real*8 lens, L, W, binsizex, binsizey

      parameter (nbeads = 38)
      parameter (ntstepseq = 4.d5)
      parameter (ntstepsva = 4.d5)
      parameter (nva = 1)
      parameter (whicRNG = 1)
      parameter (nseed = -17)
      parameter (sprtype = 4)
      parameter (nens = 1)
      parameter (Nobs = 10000)
      parameter (sstep = 400)
      parameter (maxcoll = 30000)
      parameter (maxind = 10000)
      parameter (lens = 0.554d0)
      parameter (L = 600.1d0/lens)
      parameter (W = 129.9d0/lens)
      parameter (Nbinsx = 214)
      parameter (Nbinsy = 46)
      parameter (Nbins = Nbinsx*Nbinsy)
      parameter (binsizex = L/Nbinsx)
      parameter (binsizey = W/Nbinsy)
      parameter (nobsfile = 1)
      parameter (nchainfile = 2)
      parameter (nsamp = nva*nens)

      integer binhead(Nbins), binlist(Nobs)
   
      real*8 xc(nbeads), yc(nbeads), zc(nbeads)
      real*8 xn(nbeads), yn(nbeads), zn(nbeads)
      real*8 xeq(nbeads), yeq(nbeads), zeq(nbeads)
      real*8 a, Hspr, deltar, deltinit, Nks, lambda, v, Pe, uve(3)
      real*8 xstart, Rousetime, Robs, xobs(Nobs), yobs(Nobs)
      real*8 xcmi, ycmi, xcmva(nsamp), ycmva(nsamp)
      real*8 xmin, xmax, ymin, ymax, xcm 
      real*8 estret(maxind), vstret(maxind)
      real*8 emsdx(maxind), vmsdx(maxind), ecmx(maxind), vcmx(maxind)
      real*8 lspac, ncol, ncolls(nsamp), colldist(nsamp)
      real*8 sobsx(maxcoll), sobsy(maxcoll)
            
      parameter (a = 0.d0)
      parameter (deltinit = 5.d-4)
      parameter (deltar = 5.d-4)
      parameter (Nks = 5.23d0)
      parameter (lambda = 1.91d0)
      parameter (Hspr = 3.d0*Nks/lambda)
      parameter (v = 2.35d-3)
      parameter (Pe = 10.d0)
      parameter (Robs = 0.5d0/lens)
      parameter (xstart = 3.d0)
      parameter (Rousetime = 8.91d0)
      parameter (lspac = 3.0587d0/lens)

      logical overext, isgev, istab, iseqconfig
      logical iscoords, isobscoords, readcoords

      parameter (isgev = .TRUE.)
      parameter (readcoords = .FALSE.)

      write(*, *) 'welcome'

c     check number of bins
      if(Nbinsx.ne.(int(sqrt(Nobs*L/W)))) then
        write(*, *) 'recalculate # x bins; bye'
        stop
      endif
      if(Nbinsy.ne.(int(sqrt(Nobs*W/L)))) then
        write(*, *) 'recalculate # y bins; bye'
        stop
      endif

c     initialization
      ranflag = 0
      overext = .FALSE.
      istab = .FALSE.
      iseqconfig = .FALSE.
      inovercnt = 0
      outovercnt = 0
      isamp = 0
      inquire(file = 'icoords.dat', exist = iscoords)
      do 10 ind = 1, maxind
         estret(ind) = 0.d0
         emsdx(ind) = 0.d0
         ecmx(ind) = 0.d0
         vstret(ind) = 0.d0
         vmsdx(ind) = 0.d0
         vcmx(ind) = 0.d0
 10   continue

c     unit vector in electric field direction
      uve(1) = 1.d0
      uve(2) = 0.d0
      uve(3) = 0.d0

c     check if movie.xyz file exists; if not, stop program
      inquire(file = 'movie.xyz', exist = isobscoords)
      if(.NOT.isobscoords) then
        write(*, *) 'generate obstacle coords and restart; bye'
        stop
      endif

c     read obstacle coords in units of obst dia (1 micron)
c     from Ramin's file movie.xyz
      open(unit = nobsfile, file = 'movie.xyz', status = 'OLD')
      call readobstq(nobsfile, Nobs, xobs, yobs)
      close(unit = nobsfile, status = 'KEEP')
c     nondimensionalize obst coords
      do 20 iobs = 1, Nobs
         xobs(iobs) = xobs(iobs)/lens
         yobs(iobs) = yobs(iobs)/lens
 20   continue   
      write(*, *) 'obstacle coordinates read'

c     bin the obstacles 
      call binobst(Nobs, xobs, yobs, Nbinsx, Nbinsy, Nbins,
     &             binsizex, binsizey, binhead, binlist)
      write(*, *) 'obstacles binned'

c     open file for saving xyz coords
      open(unit = 5, file = 'rla3d1p10.dat', status = 'NEW')

c     iterate over trajectories in ensemble
      do 800 iens = 1, nens
       write(*, *) 'trajectory ', iens
c      initialize array index for current traj.
       ind = 0
     
c      generate equilibrated bead coords
c      if file exists, open file containing equilibrated bead coords
       if(iscoords) then
         open(unit = nchainfile, file = 'icoords.dat', status = 'OLD')
       endif  
       call  inchainconf(nchainfile, xc, yc, zc, xeq, yeq, zeq,
     &                   xstart, W, nbeads, sprtype, Hspr, Nks, v,
     &                   Rousetime, whicRNG, ranflag, nseed, deltar,
     &                   deltinit, ntstepseq, isgev, overext,
     &                   istab, iseqconfig, iscoords, readcoords, a,
     &                   Nobs, Robs, xobs, yobs, binhead, binlist,
     &                   Nbins, Nbinsx, Nbinsy, binsizex, binsizey,
     &                   inovercnt, outovercnt, Pe, uve,
     &                   estret, sstep, maxind, inde, emsdx, ecmx)
       if(iscoords) then
         close(unit = nchainfile, status = 'KEEP')
       endif   

       iva = 1
c      enter current viewing area corresp. to iva
 50    continue
c      increment index for samples over traj. and view ar.
       isamp = isamp + 1

c      calculate starting chain center of mass x, y coords for current sample
       xcmi = xc(1)
       ycmi = yc(1)
       do 100 ibead = 2, nbeads
          xcmi = xcmi + xc(ibead)
          ycmi = ycmi + yc(ibead)
 100   continue
       xcmi = xcmi/nbeads
       ycmi = ycmi/nbeads

c      initialization for current sample
       numcoll = 0

c      time stepping for current viewing area
       do 500 istep = 1, ntstepsva

c        compute bead positions at istep from their values at istep-1
         call pc1sfdEext(xc, yc, zc, xn, yn, zn, nbeads, istep-1,
     &                   sprtype, Hspr, whicRNG, ranflag, nseed, deltar,
     &                   Nks, v, Pe, uve, overext, isgev, istab, 
     &                   inovercnt, outovercnt)
 
c        if overextended input spring remains overstretched after pred-corr,
c        reduce time step and restart program
         if(overext) then
            write(*, *) 'pred-corr returned overstretched spring'
            write(*, *) 'reduce time step and restart; bye'
            stop
         endif  
                 
c        implement HS EV with obstacles
         call mhsevobs(xn, yn, nbeads, a, binhead, binlist,
     &                 Nbinsx, Nbinsy, Nbins, binsizex,
     &                 binsizey, xobs, yobs, Nobs, Robs)

c        calculate max and min x and y coords
         xmin = xn(1)
         xmax = xn(1)
         ymin = yn(1)
         ymax = yn(1)
         do 140 ibead = 2, nbeads
            if(xn(ibead).lt.xmin) then
               xmin = xn(ibead)
            elseif(xn(ibead).gt.xmax) then
               xmax = xn(ibead)
            endif
            if(yn(ibead).lt.ymin) then
               ymin = yn(ibead)
            elseif(yn(ibead).gt.ymax) then
               ymax = yn(ibead)
            endif
 140     continue

c        count #collisions in viewing area in current time step
         call mcollcount(xn, yn, nbeads, xmin, xmax, ymin, ymax,
     &                   Nobs, xobs, yobs, Nbinsx, Nbinsy, Nbins,
     &                   binsizex, binsizey, binhead, binlist,
     &                   numcoll, maxcoll, sobsx, sobsy)
               
         if(mod(istep-1, sstep).eq.0) then          
c          to make a movie of the chain:
c          save coords to xyz file for any one sample, say isamp=1
c          i.e., iens = 1, iva = 1
           if(isamp.eq.1) then
             write(5, 1003) nbeads
             do 180 ibead = 1, nbeads
               write(5, 1002) xn(ibead), yn(ibead), zn(ibead)
 180         continue   
           endif    
c          save chain stretch, msd & cm x-coord for current view ar.
           ind = ind + 1
           if(ind.gt.maxind) then
             write(*, *) 'max array sizes exceeded; bye'
             stop
           endif
           vstret(ind) = vstret(ind) + xmax - xmin
           xcm = xn(1)
           do 190 ibead = 2, nbeads
              xcm = xcm + xn(ibead)
 190       continue
           xcm = xcm/nbeads
           vmsdx(ind) = vmsdx(ind) + (xcm-xcmi)*(xcm-xcmi)
           vcmx(ind) = vcmx(ind) + xcm-xcmi
         endif

c        transfer xn, yn, zn to xc, yc, zc for next time step
         do 200 ibead = 1, nbeads
            xc(ibead) = xn(ibead)
            yc(ibead) = yn(ibead)
            zc(ibead) = zn(ibead)
 200     continue   

c        finish iterations over time steps
 500   continue  

c      exiting current viewing area
c      calculate and save chain center of mass x, y coords
c      relative to c.m. position at the start of viewing area
       xcmva(isamp) = xn(1)
       ycmva(isamp) = yn(1)
       do 540 ibead = 2, nbeads
          xcmva(isamp) = xcmva(isamp) + xn(ibead)
          ycmva(isamp) = ycmva(isamp) + yn(ibead)
 540   continue
       xcmva(isamp) = xcmva(isamp)/nbeads - xcmi
       ycmva(isamp) = ycmva(isamp)/nbeads - ycmi
       
c      calculate #collisions per column of viewing area
       ncol = xcmva(isamp)/lspac
       ncolls(isamp) = numcoll/ncol
c      save mean collision distance
c      meaningful only if numcoll is at least 2
       if(numcoll.ge.2) then   
          colldist(isamp) = (sobsx(numcoll) - sobsx(1))/(numcoll-1)
       else
          colldist(isamp) = 0.d0
       endif

c      continue to next viewing area;
c      xc, yc, zc already contain last config of previous view ar
c      with HS EV implemented
       iva = iva + 1
       if(iva.le.nva) goto 50
  
c      finish iterations over trajectories
 800  continue
 
      close(unit = 5, status = 'KEEP')  

c     ensemble-averages
c     final value of ind, inde = final array sizes
c     data during equilibration meaningful only if 
c     equilibrated chain is generated for every traj;
c     data meaningful only if adequate ensemble size is used
      do 810 isamp = 1, inde
         estret(isamp) = estret(isamp)/nens
         ecmx(isamp) = ecmx(isamp)/nens
         emsdx(isamp) = emsdx(isamp)/nens
 810  continue
      do 820 isamp = 1, ind
         vstret(isamp) = vstret(isamp)/nens
         vcmx(isamp) = vcmx(isamp)/nens
         vmsdx(isamp) = vmsdx(isamp)/nens
 820  continue

c     save equilibrated bead coords to file
c     this config. satisfies HS EV constraints
      open(unit = 9, file = 'icla3d1p10.2.dat', status = 'NEW')  
      do 830 ibead = 1, nbeads
         write(9, 1002) xc(ibead), yc(ibead), zc(ibead)
 830  continue
      close(unit = 9, status = 'KEEP')   
     
c     write output to files
      open(unit = 10, file = 'cdla3d1p10.dat', status = 'NEW')
      write(10, 1001) (colldist(isamp), isamp = 1, nsamp)
      close(unit = 10, status = 'KEEP')
      open(unit = 11, file = 'ncla3d1p10.dat', status = 'NEW')
      write(11, 1001) (ncolls(isamp), isamp = 1, nsamp)
      close(unit = 11, status = 'KEEP')
      open(unit = 12, file = 'cmvala3d1p10.dat', status = 'NEW')
      do 840 isamp = 1, nsamp
         write(12, 1004) xcmva(isamp), ycmva(isamp)
 840  continue
      close(unit = 12, status = 'KEEP')
      open(unit = 13, file = 'vla3d1p10.dat', status = 'NEW')
      do 850 isamp = 1, ind
         write(13, 1002) vstret(isamp), vmsdx(isamp), vcmx(isamp)
 850  continue
      close(unit = 13, status = 'KEEP')
      open(unit = 14, file = 'ela3d1p10.dat', status = 'NEW')
      do 860 isamp = 1, inde
         write(14, 1002) estret(isamp), emsdx(isamp), ecmx(isamp)
 860  continue
      close(unit = 14, status = 'KEEP')  

 1001 format(1X, 1e12.6)
 1002 format(3(1X, 1e12.6))
 1003 format(i4)
 1004 format(2(1X, 1e12.6))

      write(*, *) '# input overext springs = ', inovercnt
      write(*, *) '# output overext springs = ', outovercnt
      write(*, *) 'starting coords read from file?', 
     &            (iscoords.AND.readcoords)
      write(*, *) '# time steps to equilibration = ', ntstepseq
      write(*, *) '# time steps in each viewing area = ', ntstepsva
      write(*, *) '# viewing areas per traj = ', nva
      write(*, *) 'output written. bye'

      write(*, *) 'total time taken = ', etime(elapsed)
     
      stop
      end


    
