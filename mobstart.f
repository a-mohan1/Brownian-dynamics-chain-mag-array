c     This program simulates the motion of a chain
c     in a magnetic obstacle array
c     periodic unit cell dims = L, W,  2-dimensional
c     (infinite in z-direction)
c     lattice starts at x=0
c     origin is at lower left hand corner of unit cell
c     Initially, the chain is in a coil config.
c     with the first bead at (-xstart, W/2, 0), 
c     ie, downstream, along unit cell centerline
c     Free draining conditions are assumed
c
c     Mar 23 07
c
c     Update- Apr 18 07:
c     when i say downstream, i really mean upstream.
c     xcmeq and ycmeq are calculated relative to xinit and yinit,
c     so xinit and yinit are incorrectly being added to xcmva, ycmva
c     (leads to small error in x coord; y coord is not needed)

      program mobstart

c     xc, yc, zc, xn, yn, zn = bead coords at successive time steps
c     nbeads = number of beads
c     a = bead radius (for HSEV implementation)
c     sprtype = type of spring (WLS = 4)
c     nens = ensemble size
c     Hspr = spring constant
c     whicRNG = RNG (Knuth = 1)
c     nseed = seed for RNG (-ve integer for whicRNG=1)
c     ranflag = indicates whether or not RNG has been initialized; initialized to 0
c     delt = time step size
c     Nks = number of Kuhn segments per spring
c     lambda = ratio of effective to true persistence length
c     v = EV param
c     Pe = Peclet number (\mu_0 E N \zeta A)/(k_B T)
c     uve = unit vector in field direction, x: (1,0,0)
c     ntstepseq = # time steps simulated for each traj to reach equilibration
c     ntstepsva = # time steps simulated for each traj after equilibration
c     (in the viewing area)
c     xcmeq, ycmeq = center of mass coords at ntstepseq, ie, at equilibration 
c     (relative to initial c.m.) for each traj.
c     xcmva, ycmva = center of mass coords at ntstepsva, ie, at the end
c     (relative to equilibration c.m.) for each traj.
c     ncolls = #collisions in viewing area per column for each traj
c     lspac = average lattice spacing 
c     (from RaminsCode/postprocess/spacing/space-vs-t)
c     ncol = #lattice columns in viewing area, nonintegral 
c     ie, distance covered by chain after equilibration/average lattice spacing
c     ncol = xcmva(iens)/lspac, not the same for all chains
c     numcoll = total #collisions in viewing area for given traj
c     sobsx, sobsy = saved obstacle center coords with which collisions have
c     occurred in current trajectory
c     maxcoll = max allowed number of colls per trajectory 
c     (size of arrays sobsx, sobsy)
c     xobs, yobs = array of obstacle center xy coords in periodic unit cell
c     Robs = obstacle radius
c     Nobs = total# obstacles in periodic unit cell
c     lens = length scale = max spring length
c     L, W = length and width of periodic unit cell
c     (obst centers lie in unit cell, but some portion of obst may lie outside)
c     Nbinsx, Nbinsy = # bins for obsts along x, y directions
c     Nbinsx = int(sqrt(Nobs * L/W))
c     Nbinsy = int(sqrt(Nobs * W/L))
c     => Nbinsx/Nbinsy = L/W
c     Nbins = total # bins = Nbinsx*Nbinsy
c     binsizex, binsizey = bin dimensions along x and y
c     binsizex = L/Nbinsx, binsizey = W/Nbinsy 
c     => binsizex * binsizey * Nbins = L*W
c     binhead = array of head obstacles of each bin
c     binlist = array of remaining obstacles of each bin pointed to by head
c     xstart = to be subtracted from bead x coords in starting config 
c     (chain is placed downstream along unit cell centerline)
c     overext indicates whether a spring has been overstretched
c     isgev = .TRUE. if gaussian EV is included
c     istab indicates whether or not a lookup table exists 
c     (reqd by predictor-corrector scheme)
c     iseqconfig indicates whether or not an initial eqm config
c     has been generated by subroutine geninit
c     istep = counter for time stepping
c     ibead = counter for beads
c     iobs = obstacle counter
c     iens = counter over trajectories in ensemble
c     sstep = interval of number of steps after which config is sampled
c     xeq, yeq, zeq = initial eqm bead coords
c     Config. returned by geninit has first bead at (0, 0, 0)
c     xcminit, ycminit = initial center of mass coords for traj. after
c     shifting the chain to -xstart downstream of unit cell centerline
c     Rousetime = Rouse rel time
c     tempRg = eqm rad of gyration returned by geninit, never used
c     xmin, xmax = min and max chain x coords in field (x) direction
c     ymin, ymax = min and max chain y coords
c     stret = ensemble average of stretch in field (x) direction
c     stretsq = ensemble average of squared stretch
c     isamp = sampling index
c     nsamp = sample size
c     maxnsamp = maximum allowable sample size
c     inovercnt = # times pred corr method gets overextended spring
c     outovercnt = # times pred corr method returns overextended spring
c                  (never used, since program is stopped if this happens)

c     all eqs and variables are nondimensional
c     nondimensional max spring length = 1.0

      implicit none
      real etime, elapsed(2)

      integer nbeads, ntstepseq, ntstepsva, sprtype, whicRNG, nseed
      integer ranflag, nens, Nobs, Nbinsx, Nbinsy, Nbins, maxnsamp
      integer maxcoll, sstep
      integer istep, ibead, iobs, iens, isamp, nsamp
      integer inovercnt, outovercnt, numcoll

      real*8 lens, L, W, binsizex, binsizey

      parameter (nbeads = 38)
      parameter (ntstepseq = 4.d5)
      parameter (ntstepsva = 4.d5)
      parameter (whicRNG = 1)
      parameter (nseed = -1548)
      parameter (sprtype = 4)
      parameter (nens = 100)
      parameter (Nobs = 10000)
      parameter (sstep = 400)
      parameter (maxnsamp = 30000)
      parameter (maxcoll = 30000)
      parameter (lens = 0.554d0)
      parameter (L  = 600.1d0/lens)
      parameter (W = 129.9d0/lens)
      parameter (Nbinsx = 214)
      parameter (Nbinsy = 46)
      parameter (Nbins = Nbinsx*Nbinsy)
      parameter (binsizex = L/Nbinsx)
      parameter (binsizey = W/Nbinsy)

      integer binhead(Nbins), binlist(Nobs)
   
      real*8 xc(nbeads), yc(nbeads), zc(nbeads)
      real*8 xn(nbeads), yn(nbeads), zn(nbeads)
      real*8 xeq(nbeads), yeq(nbeads), zeq(nbeads)
      real*8 a, Hspr, delt, Nks, lambda, v, Pe, uve(3)
      real*8 Robs, xstart, xobs(Nobs), yobs(Nobs), tempRg, Rousetime
      real*8 xcmeq(nens), ycmeq(nens), xcmva(nens), ycmva(nens)
      real*8 xcminit, ycminit
      real*8 xmin, xmax, ymin, ymax
      real*8 lspac, ncol, ncolls(nens)
      real*8 stret(maxnsamp), stretsq(maxnsamp)
      real*8 sobsx(maxcoll), sobsy(maxcoll)
            
      parameter (a = 0.d0)
      parameter (delt = 1.d-3)
      parameter (Nks = 5.23d0)
      parameter (lambda = 1.91d0)
      parameter (Hspr = 3.d0*Nks/lambda)
      parameter (v = 2.35d-3)
      parameter (Pe = 5.d0)
      parameter (Robs = 0.5d0/lens)
      parameter (xstart = 3.d0)
      parameter (Rousetime = 8.91d0)
      parameter (lspac = 3.0587d0/lens)
      logical overext, isgev, istab, iseqconfig

      parameter (isgev = .TRUE.)

      write(*, *) 'welcome'

c     check number of bins
      if(Nbinsx.ne.(int(sqrt(Nobs*L/W)))) then
        write(*, *) 'recalculate # x bins; bye'
        stop
      endif
      if(Nbinsy.ne.(int(sqrt(Nobs*W/L)))) then
        write(*, *) 'recalculate # y bins; bye'
        stop
      endif

c     initialization
      ranflag = 0
      overext = .FALSE.
      istab = .FALSE.
      iseqconfig = .FALSE.
      do 10 isamp = 1, maxnsamp
         stret(isamp) = 0.d0
         stretsq(isamp) = 0.d0
 10   continue
      inovercnt = 0
      outovercnt = 0

c     unit vector in electric field direction
      uve(1) = 1.d0
      uve(2) = 0.d0
      uve(3) = 0.d0

c     read obstacle coords in units of obst dia (1 micron)
c     from Ramin's file movie.xyz
      call readobst(Nobs, xobs, yobs)
c     nondimensionalize obst coords
      do 20 iobs = 1, Nobs
         xobs(iobs) = xobs(iobs)/lens
         yobs(iobs) = yobs(iobs)/lens
 20   continue   
      write(*, *) 'obstacle coordinates read'
c     bin the obstacles 
      call binobst(Nobs, xobs, yobs, Nbinsx, Nbinsy, Nbins,
     &                   binsizex, binsizey, binhead, binlist)
      write(*, *) 'obstacles binned'
      
c     open file for saving xyz coords
      open(unit = 5, file = 'rla3d1p5.dat', status = 'NEW')

c     iterate over trajectories in ensemble
      do 800 iens = 1, nens
       write(*, *) 'trajectory ', iens

c      initialize for current trajectory
       isamp = 0

c      generate initial eqm config for current trajectory
c      first bead is at the origin
       call geninit(xeq, yeq, zeq, tempRg, nbeads, sprtype, Hspr,
     &             whicRNG, ranflag, nseed, delt, Rousetime, Nks, v, 
     &             isgev, istab, iseqconfig) 

c      transfer xeq, yeq, zeq to xc, yc, zc, 
c      after shifting bead x coords downstream by subtracting xstart
c      and bead y coords to channel center line by adding W/2

       do 100 ibead = 1, nbeads
          xc(ibead) = xeq(ibead) - xstart
          yc(ibead) = yeq(ibead) + W/2.d0
          zc(ibead) = zeq(ibead)
 100   continue

c      calculate initial center of mass position for current traj
       xcminit = xc(1)
       ycminit = yc(1)
       do 120 ibead = 2, nbeads
          xcminit = xcminit + xc(ibead)
          ycminit = ycminit + yc(ibead)
 120   continue
       xcminit = xcminit/nbeads
       ycminit = ycminit/nbeads

c      implement HS EV
c      bead-obstacle EV 
       call mhsevobs(xc, yc, nbeads, a, binhead, binlist,
     &                    Nbinsx, Nbinsy, Nbins, binsizex,
     &                    binsizey, xobs, yobs, Nobs, Robs)

c      time stepping
c      compute bead positions at istep from their values at istep-1

c      iterate over time steps until equilibration
       do 300 istep = 1, ntstepseq
         
c        predictor-corrector method, accepts overstretched springs
         call pc1sfdEext(xc, yc, zc, xn, yn, zn, nbeads, istep-1, 
     &                   sprtype, Hspr, whicRNG, ranflag, nseed, delt,
     &                   Nks, v, Pe, uve, overext, isgev, istab, 
     &                   inovercnt, outovercnt)
 
c        if overextended input spring remains overstretched after pred-corr,
c        reduce time step and restart program
         if(overext) then
            write(*, *) 'pred-corr returned overstretched spring'
            write(*, *) 'reduce time step and restart; bye'
            stop
         endif  
         
c        implement HS EV with obstacles
         call mhsevobs(xn, yn, nbeads, a, binhead, binlist,
     &                  Nbinsx, Nbinsy, Nbins, binsizex,
     &                  binsizey, xobs, yobs, Nobs, Robs)

c        calculate max and min chain x coords
         xmin = xn(1)
         xmax = xn(1)
         do 140 ibead = 2, nbeads
            if(xn(ibead).lt.xmin) then
              xmin = xn(ibead)
            elseif(xn(ibead).gt.xmax) then
              xmax = xn(ibead)
            endif
 140     continue             

c        sample chain stretch
         if(mod(istep-1, sstep).eq.0) then
           if(isamp.ge.maxnsamp) then
              write(*, *) 'maximum sample size reached; bye'
              stop
           endif
           isamp = isamp + 1
c          save stretch
           stret(isamp) = stret(isamp) + xmax - xmin           
           stretsq(isamp) = stretsq(isamp) + (xmax-xmin)*(xmax-xmin)
         endif    

c        transfer xn, yn, zn to xc, yc, zc for next time step
         do 160 ibead = 1, nbeads
            xc(ibead) = xn(ibead)
            yc(ibead) = yn(ibead)
            zc(ibead) = zn(ibead)
 160     continue   

c        finish iterations over time steps
 300  continue

c      equilibration is complete
c      calculate and save chain center of mass x, y coords for current traj
c      relative to initial c.m. position
       xcmeq(iens) = xn(1)
       ycmeq(iens) = yn(1)
       do 320 ibead = 2, nbeads
          xcmeq(iens) = xcmeq(iens) + xn(ibead)
          ycmeq(iens) = ycmeq(iens) + yn(ibead)
 320  continue
       xcmeq(iens) = xcmeq(iens)/nbeads - xcminit
       ycmeq(iens) = ycmeq(iens)/nbeads - ycminit

c      enter viewing area
c      initialization for current traj
       numcoll = 0
       
c      continue time stepping
       do 500 istep = ntstepseq + 1, ntstepseq + ntstepsva

c        compute bead positions at istep from their values at istep-1
         call pc1sfdEext(xc, yc, zc, xn, yn, zn, nbeads, istep-1,
     &                   sprtype, Hspr, whicRNG, ranflag, nseed, delt,
     &                   Nks, v, Pe, uve, overext, isgev, istab, 
     &                   inovercnt, outovercnt)
 
c        if overextended input spring remains overstretched after pred-corr,
c        reduce time step and restart program
         if(overext) then
            write(*, *) 'pred-corr returned overstretched spring'
            write(*, *) 'reduce time step and restart; bye'
            stop
         endif  
                 
c        implement HS EV with obstacles
         call mhsevobs(xn, yn, nbeads, a, binhead, binlist,
     &                  Nbinsx, Nbinsy, Nbins, binsizex,
     &                  binsizey, xobs, yobs, Nobs, Robs)

c        calculate max and min x and y coords
         xmin = xn(1)
         xmax = xn(1)
         ymin = yn(1)
         ymax = yn(1)
         do 340 ibead = 2, nbeads
            if(xn(ibead).lt.xmin) then
               xmin = xn(ibead)
            elseif(xn(ibead).gt.xmax) then
               xmax = xn(ibead)
            endif
            if(yn(ibead).lt.ymin) then
               ymin = yn(ibead)
            elseif(yn(ibead).gt.ymax) then
               ymax = yn(ibead)
            endif
 340     continue

c        count #collisions in viewing area in current time step
         call mcollcount(xn, yn, nbeads, xmin, xmax, ymin, ymax,
     &                   Nobs, xobs, yobs, Nbinsx, Nbinsy, Nbins,
     &                   binsizex, binsizey, binhead, binlist,
     &                   numcoll, maxcoll, sobsx, sobsy)
               
c        sampling
         if(mod(istep-1, sstep).eq.0) then  
           if(isamp.ge.maxnsamp) then
              write(*,*) 'maximum sample size reached; bye'
              stop
           endif
           isamp = isamp + 1
c          save stretch
           stret(isamp) = stret(isamp) + xmax - xmin       
           stretsq(isamp) = stretsq(isamp) + (xmax-xmin)*(xmax-xmin)
    
c          to make a movie of the chain in the viewing area             
c          save coords to xyz file for any one trajectory, say iens=1
           if(iens.eq.1) then
             write(5, 1003) nbeads
             do 360 ibead = 1, nbeads
                write(5, 1002) xn(ibead), yn(ibead), zn(ibead)
 360        continue   
           endif
         endif    

c        transfer xn, yn, zn to xc, yc, zc for next time step
         do 380 ibead = 1, nbeads
            xc(ibead) = xn(ibead)
            yc(ibead) = yn(ibead)
            zc(ibead) = zn(ibead)
 380     continue   

c        finish iterations over time steps
 500   continue  

c      exiting viewing area
c      save number of collisions in current trajectory 
       ncolls(iens) = numcoll
 
c      calculate and save chain center of mass x, y coords for current traj
c      relative to c.m. position after equilibration
       xcmva(iens) = xn(1)
       ycmva(iens) = yn(1)
       do 520 ibead = 2, nbeads
          xcmva(iens) = xcmva(iens) + xn(ibead)
          ycmva(iens) = ycmva(iens) + yn(ibead)
 520   continue
       xcmva(iens) = xcmva(iens)/nbeads - xcmeq(iens)
       ycmva(iens) = ycmva(iens)/nbeads - ycmeq(iens)

c      finish iterations over trajectories
 800  continue

c     save sample size
      nsamp = isamp

      close(unit = 5, status = 'KEEP')

c     ensemble-averaging
      do 820 isamp = 1, nsamp
         stret(isamp) = stret(isamp)/nens
         stretsq(isamp) = stretsq(isamp)/nens
 820  continue   
     
c     calculate #collisions per column of viewing area
      do 830 iens = 1, nens
         ncol = xcmva(iens)/lspac
         ncolls(iens) = ncolls(iens)/ncol
 830  continue
     
c     write output to files
      open(unit = 10, file = 'sla3d1p5.dat', status = 'NEW')
      do 835 isamp = 1, nsamp
         write(10, 1004) stret(isamp), stretsq(isamp)
 835  continue
      close(unit = 10, status = 'KEEP')
      open(unit = 11, file = 'ncla3d1p5.dat', status = 'NEW')
      write(11, 1001) (ncolls(iens), iens = 1, nens)
      close(unit = 11, status = 'KEEP')
      open(unit = 12, file = 'cmeqla3d1p5.dat', status = 'NEW')
      do 840 iens = 1, nens
         write(12, 1004) xcmeq(iens), ycmeq(iens)
 840  continue
      close(unit = 12, status = 'KEEP')
      open(unit = 13, file = 'cmvala3d1p5.dat', status = 'NEW')
      do 860 iens= 1, nens
         write(13, 1004) xcmva(iens), ycmva(iens)
 860  continue
      close(unit = 13, status = 'KEEP')

 1001 format(1X, 1e12.6)
 1002 format(3(1X, 1e12.6))
 1003 format(i4)
 1004 format(2(1X, 1e12.6))

      write(*, *) '# input overext springs = ', inovercnt
      write(*, *) '# output overext springs = ', outovercnt
      write(*, *) '# time steps to equilibration = ', ntstepseq
      write(*, *) '# time steps in viewing area = ', ntstepsva
      write(*, *) 'sample size = ', nsamp
      write(*, *) 'output written. bye'

      write(*, *) 'total time taken = ', etime(elapsed)
     
      stop
      end


    
