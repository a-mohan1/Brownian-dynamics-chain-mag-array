c     This program simulates the motion of a chain
c     in an obstacle array (hexagonal or square)
c     Initially, the chain is in a coil config, with the first bead at (0,0,0)
c     Free draining conditions are assumed
c     The program simulates the chain until equilibration 
c     before collecting data in the viewing area
c
c     Mar 7 07

      program obstart

c     xc, yc, zc, xn, yn, zn = bead coords at successive time steps
c     nbeads = number of beads
c     eqmdist = distance covered by chain during equilibration
c     viewar = viewing area length
c     tdisteq = time taken for each traj to reach equilibration
c     tdistva = time taken for each traj to cross viewing area
c     ntrap = array of #collisions with lattice cols in viewing area
c     (all cols are expected to be equally likely to collide;
c     ensemble-average collision prob for each col,
c     assuming that a given chain can collide at most once with a col;
c     and determine collision prob per col from total ntrap/ncols)
c     ncols = number of lattice cols in viewing area
c     including 1st (at eqmdist) and last (at eqmdist + viewar)
c     i.e., ncols = 2*(viewar/lspac) + 1
c     numcoll = total #collisions in viewing area for given traj
c     obsx, obsy = xy coords of colliding obstacles for given traj
c     maxcoll = max number of collisions per trajectory 
c     (max one collision per col per traj implies maxcoll is ncols)
c     a = bead radius
c     sprtype = type of spring (WLS = 4)
c     nens = ensemble size
c     Hspr = spring constant
c     whicRNG = RNG (Knuth = 1)
c     nseed = seed for RNG (-ve integer for whicRNG=1)
c     ranflag = indicates whether or not RNG has been initialized; initialized to 0
c     delt = time step size
c     Nks = number of Kuhn segments per spring
c     lambda = ratio of effective to true persistence length
c     v = EV param
c     Pe = Peclet number (\mu_0 E N \zeta A)/(k_B T)
c     uve = unit vector in field direction, x: (1,0,0)
c     Robs = obstacle radius
c     xstart = x coord of plane at which lattice starts
c     lspac = lattice spacing
c     lattype = lattice pattern (hexagonal = 0, square = 1)
c     hchann = channel height (bottom: z=-hchann/2, top: z=hchann/2)
c              (if the chain is confined)
c     overext indicates whether a spring has been overstretched
c     isgev = .TRUE. if gaussian EV is included
c     istab indicates whether or not a lookup table exists 
c     (reqd by predictor-corrector scheme)
c     iseqconfig indicates whether or not an initial eqm config
c     has been generated by subroutine geninit
c     isateq indicates whether or not eqmdist has been covered
c     inarray indicates whether or not chain has crossed xstart
c     istep = counter for time stepping
c     ibead = counter for beads
c     iens = counter over trajectories in ensemble
c     sstep = interval of number of steps after which config is sampled
c     xeq, yeq, zeq = initial eqm bead coords
c     Rousetime = Rouse rel time
c     tempRg = eqm rad of gyration returned by geninit, never used
c     xmin, xmax = min and max chain x coords in field direction
c     ymin, ymax = min and max chain y coords in field direction
c     stret = ensemble-averaged stretch in field direction
c     isamp = sampling index
c     icol = counter over cols in viewing area
c     nsamp = sample size
c     maxnsamp = maximum allowable sample size
c     inovercnt = # times pred corr method gets overextended spring
c     outovercnt = # times pred corr method returns overextended spring
c                  (never used, since program is stopped if this happens)

c     all eqs and variables are nondimensional
c     nondimensional max spring length = 1.0

      real etime, elapsed(2)

      integer nbeads, sprtype, whicRNG, nseed, ranflag
      integer nens, lattype, ncols, numcoll
      integer istep, ibead, iens, icol, sstep, isamp, nsamp
      integer inovercnt, outovercnt, maxnsamp, maxcoll

      parameter (nbeads = 38)
      parameter (whicRNG = 1)
      parameter (nseed = -1548)
      parameter (sprtype = 4)
      parameter (nens = 100)
      parameter (lattype = 0)
      parameter (sstep = 100)
      parameter (maxnsamp = 30000)
      parameter (ncols = 101)
      parameter (maxcoll = 1000)

      real*8 ntrap(ncols)
      real*8 xc(nbeads), yc(nbeads), zc(nbeads)
      real*8 xn(nbeads), yn(nbeads), zn(nbeads)
      real*8 xeq(nbeads), yeq(nbeads), zeq(nbeads)
      real*8 a, Hspr, delt, Nks, lambda, v, Pe, uve(3)
      real*8 Robs, xstart, lspac, hchann, eqmdist, viewar
      real*8 Rousetime, tempRg, tdisteq(nens), tdistva(nens)
      real*8 xmin, xmax, ymin, ymax
      real*8 stret(maxnsamp), obsx(maxcoll), obsy(maxcoll)

      parameter (a = 0.d0)
      parameter (delt = 1.d-4)
      parameter (Nks = 5.23d0)
      parameter (lambda = 1.91d0)
      parameter (Hspr = 3.d0*Nks/lambda)
      parameter (v = 2.35d-3)
      parameter (Pe = 25.d0)
      parameter (Robs = 0.903d0)
      parameter (xstart = 3.d0)
      parameter (lspac = 5.42d0)
c      parameter (hchann = 3.61d0)
      parameter (eqmdist = 50.d0*lspac + xstart)
      parameter (viewar = 50.d0 * lspac)
      parameter (Rousetime = 8.91d0)

      logical overext, isgev, istab, iseqconfig
      logical isateq, inarray

      parameter (isgev = .TRUE.)

      write(*, *) 'welcome'

c     initialization
      ranflag = 0
      overext = .FALSE.
      istab = .FALSE.
      iseqconfig = .FALSE.
      nsamp = maxnsamp
      do 10 isamp = 1, maxnsamp
         stret(isamp) = 0.d0
 10   continue
      do 20 icol = 1, ncols
         ntrap(icol) = 0.d0
 20   continue
      inovercnt = 0
      outovercnt = 0

c     unit vector in electric field direction
      uve(1) = 1.d0
      uve(2) = 0.d0
      uve(3) = 0.d0

c     open file for saving xyz coords
      open(unit = 5, file = 'xyzla3d1p25.dat', status = 'NEW')

c     iterate over trajectories in ensemble
      do 9000 iens = 1, nens
       write(*, *) 'trajectory ', iens

c      initialization for current trajectory
       isateq = .FALSE.
       inarray = .FALSE.
       istep = 0
       isamp = 0
        
c      generate initial eqm config for current trajectory
c      first bead is at the origin
       call geninit(xeq, yeq, zeq, tempRg, nbeads, sprtype, Hspr,
     &             whicRNG, ranflag, nseed, delt, Rousetime, Nks, v, 
     &             isgev, istab, iseqconfig) 

       do 300 ibead = 1, nbeads
         xc(ibead) = xeq(ibead)
         yc(ibead) = yeq(ibead)
         zc(ibead) = zeq(ibead)
 300   continue

c      implement HS EV
c      bead-wall EV (if confined)
c       call hsevwall(zc, nbeads, a, hchann)
c      bead-obstacle EV
       if(lattype.eq.0) then
         write(*, *) 'hexagonal lattice'
         call hsevhexarray(xc, yc, nbeads, a, Robs, lspac, xstart)
       elseif(lattype.eq.1) then
         write(*, *) 'square lattice'
         call hsevsqarray(xc, yc, nbeads, a, Robs, lspac, xstart)
       else
         write(*, *) 'undefined lattice; bye'
         stop
       endif 

c      time stepping
c      compute bead positions at istep from their values at istep-1

 400   continue
       istep = istep + 1 
       call pc1sfdEext(xc, yc, zc, xn, yn, zn, nbeads, istep-1, sprtype,
     &        Hspr, whicRNG, ranflag, nseed, delt, Nks, v, Pe, uve, 
     &        overext, isgev, istab, inovercnt, outovercnt)
 
       if(overext) then
            write(*, *) 'overstretched spring; bye'
            stop
       endif  
         
c      implement HS EV
c       call hsevwall(zn, nbeads, a, hchann)
       if(lattype.eq.0) then
            call hsevhexarray(xn, yn, nbeads, a, Robs, lspac, xstart)
       elseif(lattype.eq.1) then
            call hsevsqarray(xn, yn, nbeads, a, Robs, lspac, xstart)
       else
            write(*, *) 'undefined lattice; bye'
            stop
       endif 

c      calculate max and min x coords
       xmin = xn(1)
       xmax = xn(1)
       do 800 ibead = 2, nbeads
          if(xn(ibead).lt.xmin) then
             xmin = xn(ibead)
          elseif(xn(ibead).gt.xmax) then
             xmax = xn(ibead)
          endif
 800   continue       
       
c      check if the chain has crossed the array starting plane
       if((xmax.ge.xstart).AND.(.NOT.inarray)) then
         tdisteq(iens) = istep
         inarray = .TRUE.
       endif

c      sample chain stretch
       if(mod(istep-1, sstep).eq.0) then
         if(isamp.ge.maxnsamp) then
            write(*,*) 'maximum sample size reached; bye'
            stop
         endif
         isamp = isamp + 1
c        save stretch
         stret(isamp) = stret(isamp) + xmax - xmin           
       endif    

c      transfer xn, yn, zn to xc, yc, zc for next time step
       do 900 ibead = 1, nbeads
          xc(ibead) = xn(ibead)
          yc(ibead) = yn(ibead)
          zc(ibead) = zn(ibead)
 900   continue   

c      check if equilibration dist has been covered
c      if not, continue iterations
       if(xmax.ge.eqmdist) then
          isateq = .TRUE.
       endif

       if(.NOT.isateq) then
          goto 400
       endif

c      equilibration is complete; enter viewing area
       tdistva(iens) = istep
c      save equilibration time of current traj
       tdisteq(iens) = (istep - tdisteq(iens)) * delt

c      initialization for current traj
       numcoll = 0
       
c      continue time stepping
c      compute bead positions at istep from their values at istep-1

 1000  continue
       istep = istep + 1 
       call pc1sfdEext(xc, yc, zc, xn, yn, zn, nbeads, istep-1, sprtype,
     &        Hspr, whicRNG, ranflag, nseed, delt, Nks, v, Pe, uve, 
     &        overext, isgev, istab, inovercnt, outovercnt)
 
       if(overext) then
            write(*, *) 'overstretched spring; bye'
            stop
       endif  
         
c      implement HS EV
c       call hsevwall(zn, nbeads, a, hchann)
       if(lattype.eq.0) then
            call hsevhexarray(xn, yn, nbeads, a, Robs, lspac, xstart)
       elseif(lattype.eq.1) then
            call hsevsqarray(xn, yn, nbeads, a, Robs, lspac, xstart)
       else
            write(*, *) 'undefined lattice; bye'
            stop
       endif 

c      calculate max and min x and y coords
       xmin = xn(1)
       xmax = xn(1)
       ymin = yn(1)
       ymax = yn(1)
       do 1020 ibead = 2, nbeads
          if(xn(ibead).lt.xmin) then
             xmin = xn(ibead)
          elseif(xn(ibead).gt.xmax) then
             xmax = xn(ibead)
          endif
          if(yn(ibead).lt.ymin) then
             ymin = yn(ibead)
          elseif(yn(ibead).gt.ymax) then
             ymax = yn(ibead)
          endif
 1020   continue

c      count #collisions in each viewing area col in current time step       
       call collcount(x, y, nbeads, xmin, xmax, ymin, ymax,
     &                lspac, lattype, eqmdist, numcoll,
     &                obsx, obsy, maxcoll, ntrap, ncols)
          
c      sampling
       if(mod(istep-1, sstep).eq.0) then  
         if(isamp.ge.maxnsamp) then
            write(*,*) 'maximum sample size reached; bye'
            stop
         endif
         isamp = isamp + 1
c        save stretch
         stret(isamp) = stret(isamp) + xmax - xmin       
    
c        to make a movie of the chain in the viewing area             
c        save coords to xyz file for any one trajectory, say iens=1
         if(iens.eq.1) then
           write(5, 9903) nbeads
           do 1040 ibead = 1, nbeads
              write(5, 9902) xn(ibead), yn(ibead), zn(ibead)
 1040      continue   
         endif
       endif    

c      transfer xn, yn, zn to xc, yc, zc for next time step
       do 1060 ibead = 1, nbeads
          xc(ibead) = xn(ibead)
          yc(ibead) = yn(ibead)
          zc(ibead) = zn(ibead)
 1060  continue   

c      check if the chain has left viewing area
c      if not, continue iterations
       if(xmax.lt.(eqmdist + viewar)) then
          goto 1000
       endif
      
c      leave viewing area
       tdistva(iens) = (istep - tdistva(iens)) * delt

c      identify smallest sample size among trajectories
c      so as to be able to ensemble-average stretch
       if(nsamp.gt.isamp) then
         nsamp = isamp
         ntsteps = istep
       endif

c      finish iterations over trajectories
 9000 continue

      close(unit = 5, status = 'KEEP')

c     sample size and #steps correspond to smallest 
c     among all trajectories for ensemble-averaging
c     ensemble-averaging
      do 9020 isamp = 1, nsamp
         stret(isamp) = stret(isamp)/nens
 9020 continue   
      do 9040 icol = 1, ncols
         ntrap(icol) = ntrap(icol)/nens
 9040 continue

c     write output to files
      open(unit = 10, file = 'stretla3d1p25.dat', status = 'NEW')
      write(10, 9901) (stret(isamp), isamp = 1, nsamp)
      close(unit = 10, status = 'KEEP')
      open(unit = 11, file = 'ntrapla3d1p25.dat', status = 'NEW')
      write(11, 9901) (ntrap(icol), icol = 1, ncols)
      close(unit = 11, status = 'KEEP')
      open(unit = 12, file = 'tdisteq.dat', status = 'NEW')
      write(12, 9901) (tdisteq(iens), iens = 1, nens)
      close(unit = 12, status = 'KEEP')
      open(unit = 13, file = 'tdistva.dat', status = 'NEW')
      write(13, 9901) (tdistva(iens), iens = 1, nens)
      close(unit = 13, status = 'KEEP')

 9901 format(1X, 1e12.6)
 9902 format(3(1X, 1e12.6))
 9903 format(i4)

      write(*, *) '# input overext springs = ', inovercnt
      write(*, *) '# output overext springs = ', outovercnt
      write(*, *) 'total # time steps = ', ntsteps
      write(*, *) 'total sample size = ', nsamp
      write(*, *) 'output written. bye'

      write(*, *) 'total time taken = ', etime(elapsed)
     
      stop
      end


    
